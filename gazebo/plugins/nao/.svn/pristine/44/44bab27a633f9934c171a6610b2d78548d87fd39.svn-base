// COMMENTS
/*

	Para medir el timepo de la simulacion, tomar una medida al empezar la simulaciÃ³n y otra al terminar y restarlas:
			
	    common::Time t = this->walking->getModel()->GetWorld()->GetSimTime();  //Tiempo en segundos
	    std::cout << "tiempo inic " << t.Float() << std::endl; 

	Para resetear el mundo al estado original:

		gazebo::physics::WorldPtr world = this->walking->getModel()->GetWorld();
		world->Reset();

*/




#include "walking.h"

#include <math.h>

//left side
#include "poseleftankle.h"
#include "poseleftelbow.h"
#include "poselefthip.h"
#include "poseleftknee.h"
#include "poseleftshoulder.h"

//neck
#include "poseneck.h"
#include "poseneckspeed.h"
//right side
#include "poserightankle.h"
#include "poserightelbow.h"
#include "poserighthip.h"
#include "poserightknee.h"
#include "poserightshoulder.h"

namespace gazebo {
    GZ_REGISTER_MODEL_PLUGIN(Walking);

    //CONSTRCTOR
    Walking::Walking () {
		this->cfgfile_walking = std::string("--Ice.Config=walking.cfg");
        std::cout << "Constructor Walking" << std::endl;
    }

    //LOAD
    void Walking::Load ( physics::ModelPtr _model, sdf::ElementPtr _sdf ) {
        
        pthread_t thr_ice;
        pthread_create(&thr_ice, NULL, &thread_WalkingICE, (void*) this);
		
		model = _model;

        // Load OnUpdate method
        this->updateConnection = event::Events::ConnectWorldUpdateBegin(
            boost::bind(&Walking::OnUpdate, this));
    }

	physics::ModelPtr Walking::getModel()
    {
    	return model;
    }

    void Walking::Init () { }

    void Walking::OnUpdate () { }

    class WalkerI : virtual public jderobot::Walker {
    public:

		WalkerI(gazebo::Walking* walking) : walkerData(new jderobot::WalkerData()) {
			this->walking = walking;	
		}

        virtual ~WalkerI() {};

		void sleep(unsigned long milisec) {
		
		//unsigned long milisec = 3000L;
		struct timespec req={0};
	   	time_t sec=(int)(milisec/1000);
	    	milisec=milisec-(sec*1000);
	    	req.tv_sec=sec;
	    	req.tv_nsec=milisec*1000000L;
	    	while(nanosleep(&req,&req)==-1)
		    continue;
	    }

		void resetWorld() {
		
			  std::cout << "en reload" << std::endl;
			  gazebo::physics::WorldPtr world = this->walking->getModel()->GetWorld();
			  world->Reset();
		}
	
		virtual Ice::Int stopWalk (const Ice::Current&) {

		}

		virtual Ice::Int setParams(const jderobot::WalkerDataPtr&  walkerData,
		    						     const Ice::Current&) {

			std::cout << "en setParams" << std::endl;

		         // I should check the value of h, in case this is 0 and therefore
		         //    the point is in the inifnity

			pthread_mutex_lock(&walking->mutex2);

			walking->my_params.param1 = walkerData->param1;	
			walking->my_params.param2 = walkerData->param2;	
			walking->my_params.param3 = walkerData->param3;	
			walking->my_params.param4 = walkerData->param4;	
			walking->my_params.param5 = walkerData->param5;	
			walking->my_params.param6 = walkerData->param6;	
			walking->my_params.param7 = walkerData->param7;	
			walking->my_params.param8 = walkerData->param8;	
			walking->my_params.param9 = walkerData->param9;	
			walking->my_params.param10 = walkerData->param10;	

std::cout << "param1: " << walkerData->param1 << std::endl;
std::cout << "param2: " << walkerData->param2 << std::endl;
std::cout << "param3: " << walkerData->param3 << std::endl;
std::cout << "param4: " << walkerData->param4 << std::endl;
std::cout << "param5: " << walkerData->param5 << std::endl;
std::cout << "param6: " << walkerData->param6 << std::endl;
std::cout << "param7: " << walkerData->param7 << std::endl;
std::cout << "param8: " << walkerData->param8 << std::endl;
std::cout << "param9: " << walkerData->param9 << std::endl;
std::cout << "param10: " << walkerData->param10 << std::endl;

			pthread_mutex_unlock(&walking->mutex2);

		    
		    return 0;
		}

		virtual Ice::Int startWalk (const Ice::Current&) {
			
			std::cout << "en startWalk" << std::endl;

			try {
	
			//AQUI VA EL GENERADOR DE ONDA DE LA CAMINATA PARAMETRIZADA!!!!!
			//GENERAR LOS VALORES PARA TODAS LAS ARTICULACIONES Y COMANDAR EL ROBOT MEDIANTE LOS PUNTEROS A DICHAS ARTICS.
		
			

			} catch (const Ice::Exception& e) {
		            std::cerr << e << std::endl;
	        } catch (const char* msg) {
	            std::cerr << msg << std::endl;
	        }
		};

	private:
		jderobot::WalkerDataPtr  walkerData;	
	public:
		gazebo::Walking* walking;
    };



    /* this thread offers external communications */
    void* thread_WalkingICE ( void* v ) {

        gazebo::Walking* walking = (gazebo::Walking*)v;
        char* name = (char*) walking->cfgfile_walking.c_str();
        Ice::CommunicatorPtr ic;
        int argc = 1;
        Ice::PropertiesPtr prop;
        char* argv[] = {name};

        try {
            ic = Ice::initialize(argc, argv);

            prop = ic->getProperties();

	    
	    	std::string EndpointsWalk = prop->getProperty("Walk.Endpoints");
	    	std::cout << "Walk Endpoints > " << EndpointsWalk << std::endl;

	    	Ice::ObjectAdapterPtr AdapterWalk = 
		    ic->createObjectAdapterWithEndpoints("AdapterWalking", EndpointsWalk);

	    	Ice::ObjectPtr walk = new WalkerI(walking);
      
	    	AdapterWalk->add(walk, ic->stringToIdentity("Walking"));

	    	AdapterWalk->activate();

        	ic->waitForShutdown();
        } catch (const Ice::Exception& e) {
            std::cerr << e << std::endl;
        } catch (const char* msg) {
            std::cerr << msg << std::endl;
        }
        if (ic) {
            try {
                ic->destroy();
            } catch (const Ice::Exception& e) {
                std::cerr << e << std::endl;
            }
        }
    }
}
